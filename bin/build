#!/bin/bash
#
# $Info: Invoke cmake/make in build directory if present and generate logfile. $
# $Syntax: build [OPTIONS] TARGET $
# $Options: -d => debug mode; -gdb => invoke with gdb; -run => execute after compile; -v => verbose compile

# Check for proper environment
let error_count=0
function Error() {
  echo "ERROR: $@" 1>&2
  let error_count++
}
for var in SYSTEMC PROJ_ROOT CXX CC ; do
  perl -e 'exit (not exists $ENV{"$ARGV[0]"})' $var ||\
    Error "Missing definition of \$$var."
done
sc_ver_file="$SYSTEMC/include/sysc/kernel/sc_ver.h"
if [[ ! -r $sc_ver_file ]]; then
  Error "SYSTEMC does not refer to a proper installation."
fi

# Setup option defaults
HERE=$(/bin/pwd)
TARGET="" # default
MAKER=""
CMAKE_OPTS=""
MAKE_OPTS=""
RUN_OPTS=""
ARGS=""
BUILD_LOGNAME='build.log'
RUN_LOGNAME='run.log'
RUN_FLAG=0
CLEAN_FLAG=0
GDBP=""
# If name of script is run...
if [[ $0 =~ .*run ]]; then
  RUN_FLAG=1
fi

# Put up a big banner
printf "|\n|\n|\n"
if [[ $error_count == 0 ]]; then
clear;
fi
ruler '*'

# Determine build directory (may be overridden later)
ROOT_DIR="."
BUILD_DIR="."
if [[ -r ./build ]]; then
  ROOT_DIR=".."
  BUILD_DIR="build"
fi

# Scan command-line for option overrides
while [[ "$1" =~ -.* ]]; do
  if [[ "$1" == "-v" ]]; then
    MAKE_OPTS="${MAKE_OPTS} VERBOSE=1"
    RUN_OPTS="${RUN_OPTS} -v"
    VERBOSE=1
    shift
  elif [[ "$1" == "-norun" ]]; then
    RUN_FLAG=1
    shift
  elif [[ "$1" == "-run" ]]; then
    RUN_FLAG=1
    shift
  elif [[ "$1" == "-clean" ]]; then
    CLEAN_FLAG=1
    shift
  elif [[ "$1" == "-gdb" ]]; then
    RUN_FLAG=1
    GDBP=gdb
    shift
  elif [[ "$1" == "-B" ]]; then
    if [[ $# -ge 2 ]]; then
      ROOT_DIR=".."
      BUILD_DIR="$2"
      shift
    else
      Error "Must supply directory name with $1 option."
    fi
    shift
  elif [[ "$1" == "-M" ]]; then
    if [[ $# -ge 2 ]]; then
      MAKER="$2"
      shift
    else
      Error "Must supply directory name with $1 option."
    fi
    shift
  elif [[ "$1" == "-debug" ]]; then
    CMAKE_OPTS="${CMAKE_OPTS} -DCMAKE_BUILD_TYPE=Debug"
    RUN_OPTS="${RUN_OPTS} -debug"
    shift
  elif [[ "$1" == "-a" ]]; then
    shift
    ARGS="$ARGS $1"
    shift
  else
    break
  fi
done
if [[ -r CMakeLists.txt ]]; then
  TARGET=$(perl -lane 'if(m{add_executable[\(] *([^[:space:]]+)}){print $1; exit 0;}' CMakeLists.txt)
fi
if [[ $# > 0 ]]; then
  TARGET="$1"
  shift
elif [[ "$TARGET" == "" ]]; then
  echo "INFO: Using default target - all"
else
  echo "INFO: Using default target - $TARGET"
fi
if [[ "$TARGET" != "" ]]; then
  if [[ $error_count == 0 ]]; then
    header -uc "$TARGET"
  else
    echo "> $TARGET"
  fi
fi

# Choose build-system
if [[ "$(which $MAKER)" == '' ]]; then
  for MAKER in ninja gmake make; do
    if [[ "$(which $MAKER)" != '' ]]; then
      break
    fi
  done
fi
if [[ "$(which $MAKER)" == '' ]]; then
  Error "Unable to find valid 'make' tool"
fi
GENERATOR='Unix Makefiles'
test "$MAKER" == 'ninja' && GENERATOR='Ninja'

if [[ error_count -gt 0 ]]; then
  echo "Please fix errors and retry."
  exit 1
fi

# Move into build directory if present (recommended)
if [[ "$BUILD_DIR" != '.' ]]; then
  mkdir -p "$BUILD_DIR"
  echo "cd $BUILD_DIR"
  cd $BUILD_DIR 1>/dev/null
fi

# Build
rm -f $BUILD_LOGNAME $RUN_LOGNAME $ROOT_DIR/$BUILD_LOGNAME $ROOT_DIR/$RUN_LOGNAME
if [[ -r $ROOT_DIR/CMakeLists.txt ]]; then
  echo "cmake -G "$GENERATOR" ${CMAKE_OPTS} $ROOT_DIR 2>&1 | tee -a $BUILD_LOGNAME"
  cmake -G "$GENERATOR" "${CMAKE_OPTS}" -S $ROOT_DIR
fi
if [[ $CLEAN_FLAG == 1 ]]; then
  echo "$MAKER clean 2>&1 | tee -a $ROOT_DIR/$BUILD_LOGNAME"
  $MAKER clean 2>&1 | tee -a $ROOT_DIR/$BUILD_LOGNAME
fi
if [[ "$TARGET" == "" ]]; then
  TARGET=$($MAKER help | perl -lane '/^\.\.\. .*\.x$/ && print $F[1]')
  header -uc "$TARGET"
fi
if [[ -x $TARGET ]]; then rm $TARGET; fi
echo "$MAKER $TARGET ${MAKE_OPTS} 2>&1 | tee -a $ROOT_DIR/$BUILD_LOGNAME"
$MAKER $TARGET ${MAKE_OPTS} 2>&1 | c++filt |tee -a $ROOT_DIR/$BUILD_LOGNAME
filter-mlog $ROOT_DIR/$BUILD_LOGNAME

# Run
if [[ $RUN_FLAG == 1 ]]; then
  cd $ROOT_DIR;
  env DEBUG=1\
    LD_LIBRARY_PATH=$SYSTEMC/lib \
    DYLD_LIBRARY_PATH=$SYSTEMC/lib \
  $GDBP $BUILD_DIR/$TARGET -- $RUN_OPTS $ARGS 2>&1 \
  | tee $BUILD_DIR/$RUN_LOGNAME;

  if [[ "$ROOT_DIR" != "$BUILD_DIR" ]]; then
    #filter-sclog $BUILD_DIR/$RUN_LOGNAME | c++filt >$RUN_LOGNAME;
    c++filt < $BUILD_DIR/$RUN_LOGNAME >$RUN_LOGNAME;
  else
    # filter-sclog $BUILD_DIR/$RUN_LOGNAME | c++filt >$BUILD_DIR/run2.log;
    c++filt < $BUILD_DIR/$RUN_LOGNAME >$BUILD_DIR/run2.log;
    rm $BUILD_DIR/$RUN_LOGNAME
    mv $BUILD_DIR/run2.log $RUN_LOGNAME
  fi
fi
if [[ -r $BUILD_LOGNAME ]]; then
  echo "Info: Created $BUILD_LOGNAME"
fi
if [[ -r $RUN_LOGNAME ]]; then
  echo "Info: Created $RUN_LOGNAME"
fi

# The end
